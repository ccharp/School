%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

extern int yylineno;
int yydebug = 1;

extern void yyerror( char* );
extern int yylex();
%}

/*********************************************************
 ********************************************************/
%union {
    char* id;
}

%token <id> ID
%token INTVAL
%token VOID CHAR SHORT INT LONG FLOAT DOUBLE PTR 
%token STATIC
%token RETURN WHILE SWITCH DEFAULT ELSE BREAK DO FOR CASE IF
%token CONTINUE GOTO UNSIGNED CONST EXTERN REGISTER TYPEDEF
%token UNION AUTO PREPROC INTVAL FLTVAL DBLVAL STRVAL CHARVAL
%token SEMICOLON LEFTPAREN RIGHTPAREN LEFTBRACKET RIGHTBRACKET
%token RIGHTSQRBRACK LEFTSQRBRACK COMMA
%token AND OR 
%token PLUSEQ DIVEQ ANDEQ RIGHTSHIFTEQ
%token STRUCT SIZEOF 
%token BITSHIFTRIGHTEQ SUBEQ MODEQ XOREQ GTEQ MULTEQ OREQ
%token BITSHIFTLEFTEQ BITSHIFTLEFT BITSHIFTRIGHT

%token BITSHIFTR BITSHIFTL GTE LTE EQ NOTEQ

%start top

%%

/*********************************************************
 * The top level parsing rule, as set using the %start
 * directive above. You should modify this rule to
 * parse the contents of a file.
 ********************************************************/
top : /* empty rule */
	| funcHeader top {printf("funcHeader rule\n");}

	

funcHeader : type ID '(' argsHeader ')' '{' body '}'

argsHeader : 
		  | type {printf("type\n");}
		  | type ',' argsHeader 

body : 
	 | statement body

statement : 
		  | RETURN expr
		  | '{' statement '}'
		  | funcCall
		  | 
		  | WHILE '(' expr ')' '{' body '}'  

funcCall : ID '(' args ')'';' {printf("function: %s\n", $1);}



type : VOID 
	 | CHAR 
	 | SHORT 
	 | INT 
	 | LONG 
	 | FLOAT
	 | DOUBLE
	 | PTR type
	 | type '[' INTVAL ']'
	 | type '[' ']' 

/*********************************************************
 * An example rule used to parse arguments to a
 * function call. The arguments to a function call
 * can either be nothing, one parameter, or multiple
 * parameters separated by commas.
 ********************************************************/
args : /* empty rule */
     | expr
	 | funcCall
     | expr ',' args
	 | funcCall ',' args

/*********************************************************
 * An example rule used to parse a single expression.
 * Currently this rule parses only an integer value
 * but you should modify the rule to parse the required
 * expressions.
 ********************************************************/
expr : INTVAL ';'
	 | expr '+' INTVAL
	 | expr '-' INTVAL
	 | expr '*' INTVAL
	 | expr '/' INTVAL
	 | expr '>' INTVAL
	 | expr '<' INTVAL
	 | expr '%' INTVAL
	 | expr '|' INTVAL
	 | expr '&' INTVAL
	 | expr '^' INTVAL
	 | expr BITSHIFTR INTVAL
	 | expr BITSHIFTL INTVAL
	 | expr GTE 	  INTVAL
	 | expr LTE       INTVAL
	 | expr EQ 		  INTVAL
	 | expr NOTEQ 	  INTVAL
	 ;
%%

/*********************************************************
 * This method is invoked by the parser whenever an
 * error is encountered during parsing; just print
 * the error to stderr.
 ********************************************************/
void yyerror( char *err ) {
    fprintf( stderr, "at line %d: %s\n", yylineno, err );
}

/*********************************************************
 * This is the main function for the function call
 * graph program. We invoke the parser and return the
 * error/success code generated by it.
 ********************************************************/
int main( int argc, const char *argv[] ) {
    printf( "digraph funcgraph {\n" );
    int res = yyparse();
    printf( "}\n" );

    return res;
}
